\documentclass[10pt,serif,draftclsnofoot,onecolumn]{IEEEtran}
\usepackage{color}
\usepackage{setspace}
\usepackage{url}
\singlespacing

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\begin{document}
	\begin{titlepage}


	\title{ \normalsize \textsc{}
			\\ [2.0cm]
			\HRule{0.5pt} \\
			\LARGE \textbf{\uppercase{Writing topic four}}
			\\ \normalsize \textsc{Interrupts and Synchronization}
			\HRule{2pt} \\ [0.5cm]
			\normalsize \today \vspace*{5\baselineskip}}
	\date{10/16/2016}
	
	\author{Steven Silvers \\
			Oregon State University \\
			CS 444 Operating Systems II}
	\pagenumbering{gobble}	
	\maketitle
	\end{titlepage}
	\newpage
	\pagenumbering{arabic}
	\section{Interrupts and Synchronization in Linux}
	\par
			Interrupts in the Linux operating system are split into two main categories, top halves and bottom halves. Top halves deal with hardware events that are timing critical, meaning that a top half interrupt cannot sleep or block. The main function of the top half is to make sure that the hardware is ready to handle the incoming interrupt request.
	\newline
	\par
			Anything that does not fall into the top half category is called a bottom half. Bottom halves are not as time sensitive as top halves, so some bottom halves can sleep, block and can also be interrupted. There are three main types of bottom halves currently used in the Linux kernel, and those are softirqs, tasklets and work queues\cite{2}. Softirqs are rarely used, as they cannot be dynamically allocated or destroyed and there is a maximum of 32 softirqs in existence within the kernel. Because of these limitations, most interrupt drivers are written with tasklets. Tasklets are built on and processed by softirqs based on their priority level. The key advantage of using tasklets is that they can be dynamically allocated and destroyed\cite{2}. Work queues are completely different from softirqs and tasklets in that while the first two run in interrupt context, work queues run in process context. This means that they run like a normal process, with the ability to sleep and block. This allows work queues to perform tasks such as memory allocation and I/O.
	\newline
	\par
			Synchronization is necessary in every modern operating system, which includes Linux. Synchronization tools are needed whenever processes might execute concurrently to prevent the creation of race conditions. To attempt to prevent race conditions in Linux, a concept called critical sections was implemented. A critical section is a segment of code that is protected from concurrent multiple access\cite{3}. Whenever a thread is operating within a critical section, all other threads are excluded from that critical section. The problem this can raise is that of deadlock. If their are two protected resources, and two different threads each are currently accessing one of resources but need to use both resources to finish executing their process, neither thread will be able to complete their process as they will permanently lock each other out of their respective resources.
	\newline
	\par
			One way that synchronization is implemented in the Linux kernel is called a spinlock. A spinlock is a busy-wait method of mutual exclusion. If the lock is available, the thread takes the lock and runs what it needs to run and then releases the lock. If the lock is unavailable the thread busy-waits on the lock until it becomes available again\cite{3}. Other synchronization methods in the Linux kernel include atomic functions, reader/writer locks, mutexes and the Big kernel Lock.
	\section{Interrupts and Synchronization in Windows}
	\par
			At a high level, the Windows operating system handles interrupts in a fairly similar way to Linux. Only when you get into the finer details do you start to notice a difference. Instead of top halves and bottom halves, Windows uses what it calls "traps" which are mechanisms in the kernel that capture a thread that is currently executing when an interrupt occurs. Control is then transferred to a trap handler, which is responsible for running a function that is specific to whatever interrupt or exception that occurred\cite{5}. The kernel distinguishes interrupts from exceptions in that interrupts are asynchronous events that have nothing to do with what the CPU was currently running, such as I/O. Exceptions are synchronous and are usually caused by whatever the CPU was running at the time.
	\newline
	\par
			The Windows operating system sets interrupt priority with a system called Interrupt Request Level (IRQL). This is represented in the kernel on x86 systems as number 0 through 31. The higher the number, the higher the priority of the interrupt. A level 0 means to run it at regular thread execution, 1 and 2 are software level interrupts and 3 through 31 are all various types of hardware interrupts\cite{5}.
			
	\newpage


	\bibliography{writing4bib}
	\bibliographystyle{ieeetr}


\end{document}